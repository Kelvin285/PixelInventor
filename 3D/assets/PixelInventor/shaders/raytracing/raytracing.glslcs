#version 430 core

layout(binding = 0, rgba32f) uniform image2D framebuffer;

layout (binding = 0) uniform sampler2D tile_texture;

layout(std430, binding = 2) buffer vBuffer
{
	int voxels[];
};

layout(std430, binding = 3) readonly buffer cBuffer
{
	int chunks[];
};

layout(std430, binding = 4) readonly buffer oBuffer
{
	int octs[];
};

struct cubemap {
	vec4 top;
	vec4 bottom;
	vec4 left;
	vec4 right;
	vec4 front;
	vec4 back;
	vec4 size;
};

layout(std430, binding = 5) readonly buffer tBuffer
{
	cubemap cube_maps[];
};

uniform int width;
uniform int length;
uniform int height;

uniform int chunk_size;
uniform int oct_size;
uniform int shadows;
uniform int reflections;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;

uniform vec3 skyColor;
uniform vec3 sunColor;
uniform vec3 sunPosition;
uniform ivec3 world_position;

struct material {
	vec4 color;
	float reflectance;
	float transparency;
};

struct box {
  vec3 min;
  vec3 max;
  material mat;
};

#define MAX_SCENE_BOUNDS 1000.0
#define MAX_BOXES 100
material default_material = {vec4(1, 1, 1, 1), 0.0f, 0.0f};

box makeBox(vec3 position, material mat) {
	box b = {position, position + vec3(1, 1, 1), mat};
	return b;
}


int NUM_BOXES = 0;
box boxes[] = {
	makeBox(vec3(0, 0, 0), default_material)
};


struct hitinfo {
  vec2 lambda;
  int bi;
  box b;
  bool hasCubemap;
  cubemap cmap;
};

struct hitvoxel {
	bool hit;
	vec2 lambda;
	box b;
	int voxel;
};

vec2 intersectBox(vec3 origin, vec3 dir, const box b) {
  vec3 tMin = (b.min - origin) / dir;
  vec3 tMax = (b.max - origin) / dir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar = min(min(t2.x, t2.y), t2.z);
  return vec2(tNear, tFar);
}

vec3 INTERSECT_POS = vec3(0, 0, 0);
const vec3 ONE = vec3(1, 1, 1);

hitvoxel intersectVoxel(vec3 origin, vec3 dir, int x, int y, int z) {
	INTERSECT_POS.x = x;
	INTERSECT_POS.y = y;
	INTERSECT_POS.z = z;
	hitvoxel h;
	h.hit = false;
	box b = {INTERSECT_POS, INTERSECT_POS + ONE, default_material};
	h.b = b;
	h.lambda = intersectBox(origin, dir, b);
	h.voxel = 0;
	if (x >= 0 && y >= 0 && z >= 0 && x < width && y < height && z < length) {
		h.hit = true;
		h.voxel = voxels[x + y * width + z * width * height];
	}
	return h;
}

int getVoxel(int x, int y, int z) {
	if (x >= 0 && y >= 0 && z >= 0 && x < width && y < height && z < length) return voxels[x + y * width + z * width * height];
	return 0;
}

int getChunk(int x, int y, int z) {
    int num_chunks = width / chunk_size;
	if (x >= 0 && y >= 0 && z >= 0 && x < num_chunks && y < num_chunks && z < num_chunks) return chunks[x + y * num_chunks + z * num_chunks * num_chunks];
	return 0;
}

int getOct(int x, int y, int z) {
	int num_chunks = width / chunk_size;
  	int num_octs = width / oct_size;
  	if (x >= 0 && y >= 0 && z >= 0 && x < num_octs && y < num_octs && z < num_octs) return octs[x + y * num_octs + z * num_octs * num_octs];
	return 0;
}

float bias = 0.001;
const float voxelstep = bias;


bool intersectBoxes(vec3 origin, vec3 dir, out hitinfo info) {
	
	
  int maxDist = 1000;
  
  float smallest = MAX_SCENE_BOUNDS;
  bool found = false;
  bool foundChunk = false;
  
  vec3 currentPos = origin;
  vec3 vstep = dir * voxelstep;

  vec3 csize = vec3(chunk_size);
  
  
  
  if (foundChunk == false) {
  	 box chunk = {vec3(0.0), vec3(width, height, length), default_material};
	  vec2 l = intersectBox(origin, dir, chunk);
	  if (l.x > 0.0 && l.x < l.y) {
		  vec3 hit = origin + dir * l[0] - vstep;
		  currentPos = hit;
		  foundChunk = true;
	  }
  }
  int num_chunks = width / chunk_size;
  int num_octs = width / oct_size;
  
  vec3 osize = vec3(oct_size);
  
  for (int i = 0; i < maxDist; i++) {
  	int x = int(floor(currentPos.x));
  	int y = int(floor(currentPos.y));
  	int z = int(floor(currentPos.z));
  	
  	
  	if (i > 0) {
  		if (x < 0 || y < 0 || z < 0 || x > width || y > height || z > length) {
  			break;
  		}
  	}
  	
  	bool ignore = false;
  	if (x >= 0 && y >= 0 && z >= 0 && x < width  && y < height && z < length) {
  		int cx = x / chunk_size;
	  	int cy = y / chunk_size;
	  	int cz = z / chunk_size;
	  	if (getChunk(cx, cy, cz) == 0) {
	  		vec3 chunkstart = vec3(cx * chunk_size, cy * chunk_size, cz * chunk_size);
		  	vec3 chunkend = chunkstart + csize;
		  	box chunk = {chunkstart, chunkend, default_material};
		  	vec2 l = intersectBox(origin, dir, chunk);
		  	vec3 endpos = origin + dir * l[1];
		  	currentPos = endpos + vstep;
		  	ignore = true;
	  	}
	  	
	  	if (!ignore) {
	  		int ox = x / oct_size;
	  		int oy = y / oct_size;
	  		int oz = z / oct_size;
	  		if (getOct(ox, oy, oz) == 0) {
	  			vec3 chunkstart = vec3(ox * oct_size, oy * oct_size, oz * oct_size);
			  	vec3 chunkend = chunkstart + osize;
			  	box chunk = {chunkstart, chunkend, default_material};
			  	vec2 l = intersectBox(origin, dir, chunk);
			  	vec3 endpos = origin + dir * l[1];
			  	currentPos = endpos + vstep;
			  	ignore = true;
	  		}
	  	}
  	}
  	
  	if (!ignore) {
  		hitvoxel hit = intersectVoxel(origin, dir, x, y, z);
  	
	  	int voxel = hit.voxel;
	  	
		if (voxel != 0) {
			if (hit.lambda.x > 0 && hit.lambda.x < hit.lambda.y) {
				info.lambda = hit.lambda;
				info.b = hit.b;
				info.cmap = cube_maps[voxel];
				info.hasCubemap = true;
				return true;
			}	
		}
		vec3 endpos = origin + dir * hit.lambda[1];
		currentPos = endpos + vstep;
  	}
  	
  }
  
  return found;
}



vec4 traceLight(vec3 origin, vec3 dir) {
  hitinfo i;
  if (intersectBoxes(origin, dir, i)) {
  
  	vec3 hitnear = origin + dir * i.lambda[0];
  	
  	return vec4(vec3(0.5), 1);
  }
  return vec4(sunColor.xyz, 1.0);
}

vec4 getTexture(vec2 start, vec2 end, vec2 current, vec4 uv, float width, float height, sampler2D tex) {
	current -= start;
	vec2 size = end - start;
	vec2 normalized = vec2(current.x / size.x, current.y / size.y);
	
	normalized /= vec2(width, height);
	normalized.x += (1.0 / width) * mod(start.x, width);
	normalized.y += (1.0 / height) * mod(start.y, height);
	
	normalized = vec2(1.0) - normalized;
	vec2 UVpos = vec2(uv.xy);
	UVpos += (uv.zw - uv.xy) * normalized;
	
	return texture(tex, UVpos);
}

vec4 traceReflection(vec3 origin, vec3 dir) {
  hitinfo i;
  
  
  if (intersectBoxes(origin, dir, i)) {
  	//check for sunlight
  	
  	vec3 hitnear = origin + dir * i.lambda[0];
  	vec3 hitfar = origin + dir * i.lambda[1];
  	
  	
  	vec3 normal = vec3(0, 0, 0);
  	
  	vec4 tex = vec4(1.0);
  	
  	//ivec2 tpos = ivec2(gl_GlobalInvocationID.xy);
    //vec2 screenNormalized = vec2(tpos.x / 1920.0, tpos.y / 1080.0);
    //vec4 img = texture(tile_texture, screenNormalized);
    
    if (i.hasCubemap) {
    	cubemap cmap = i.cmap;
    	vec2 texStart;
	    vec2 texEnd;
	    vec2 texCurrent;
	    vec4 texUV = vec4(0, 0, 32.0, 2.0);
	    
	    //top, bottom, left, right, front, back
	    
	  	//left
	  	if (hitnear.x >= i.b.min.x - bias && hitnear.x <= i.b.min.x + bias) {
	  		normal = vec3(-1, 0, 0);
	  		texStart = vec2(i.b.min.z, i.b.min.y);
	  		texEnd = vec2(i.b.max.z, i.b.max.y);
	  		texCurrent = vec2(hitnear.z, hitnear.y);
	  		texUV = cmap.left;
	  	}
	  	//bottom
	  	if (hitnear.y >= i.b.min.y - bias && hitnear.y <= i.b.min.y + bias) {
	  		normal = vec3(0, -1, 0);
	  		texStart = vec2(i.b.min.x, i.b.min.z);
	  		texEnd = vec2(i.b.max.x, i.b.max.z);
	  		texCurrent = vec2(hitnear.x, hitnear.z);
	  		texUV = cmap.bottom;
	  	}
	  	//front
	  	if (hitnear.z >= i.b.min.z - bias && hitnear.z <= i.b.min.z + bias) {
	  		normal = vec3(0, 0, -1);
	  		texStart = vec2(i.b.min.x, i.b.min.y);
	  		texEnd = vec2(i.b.max.x, i.b.max.y);
	  		texCurrent = vec2(hitnear.x, hitnear.y);
	  		texUV = cmap.front;
	  	}
	  	//right
	  	if (hitnear.x >= i.b.max.x - bias && hitnear.x <= i.b.max.x + bias) {
	  		normal = vec3(1, 0, 0);
	  		texStart = vec2(i.b.min.z, i.b.min.y);
	  		texEnd = vec2(i.b.max.z, i.b.max.y);
	  		texCurrent = vec2(hitnear.z, hitnear.y);
	  		texUV = cmap.right;
	  	}
	  	//top
	  	if (hitnear.y >= i.b.max.y - bias && hitnear.y <= i.b.max.y + bias) {
	  		normal = vec3(0, 1, 0);
	  		texStart = vec2(i.b.min.x, i.b.min.z);
	  		texEnd = vec2(i.b.max.x, i.b.max.z);
	  		texCurrent = vec2(hitnear.x, hitnear.z);
	  		texUV = cmap.top;
	  	}
	  	//back
	  	if (hitnear.z >= i.b.max.z - bias && hitnear.z <= i.b.max.z + bias) {
	  		normal = vec3(0, 0, 1);
	  		texStart = vec2(i.b.min.x, i.b.min.y);
	  		texEnd = vec2(i.b.max.x, i.b.max.y);
	  		texCurrent = vec2(hitnear.x, hitnear.y);
	  		texUV = cmap.back;
	  	}
	  	
	  	
	  	tex = getTexture(texStart, texEnd, texCurrent, texUV, cmap.size.x, cmap.size.y, tile_texture);
    }
    
  	
  	hitnear -= dir * bias;
  	
  	
  	vec3 sunPos = sunPosition + hitnear;
  	
  	
  	vec3 sunVector = sunPos - hitnear;
  	
  	float len = sunVector.length();
  	vec3 sunDirection = sunVector / len;
  	
  	vec4 light = vec4(1.0);
  	if (shadows == 1) {
  		light = traceLight(hitnear, sunDirection);
  	}
  	
  	box b = i.b;
    return vec4(light.xyz, 1.0) * b.mat.color * tex;
  }
  return vec4(skyColor.xyz, 1.0);
}

vec4 trace(vec3 origin, vec3 dir) {
  hitinfo i;
  origin -= world_position * chunk_size;
  
  if (intersectBoxes(origin, dir, i)) {
  	//check for sunlight
  	
  	vec3 hitnear = origin + dir * i.lambda[0];
  	vec3 hitfar = origin + dir * i.lambda[1];
  	
  	
  	vec3 normal = vec3(0, 0, 0);
  	
  	vec4 tex = vec4(1.0);
  	
  	//ivec2 tpos = ivec2(gl_GlobalInvocationID.xy);
    //vec2 screenNormalized = vec2(tpos.x / 1920.0, tpos.y / 1080.0);
    //vec4 img = texture(tile_texture, screenNormalized);
    
     if (i.hasCubemap) {
    	cubemap cmap = i.cmap;
    	vec2 texStart;
	    vec2 texEnd;
	    vec2 texCurrent;
	    vec4 texUV = vec4(0, 0, 32.0, 2.0);
	    
	    //top, bottom, left, right, front, back
	    
	  	//left
	  	if (hitnear.x >= i.b.min.x - bias && hitnear.x <= i.b.min.x + bias) {
	  		normal = vec3(-1, 0, 0);
	  		texStart = vec2(i.b.min.z, i.b.min.y);
	  		texEnd = vec2(i.b.max.z, i.b.max.y);
	  		texCurrent = vec2(hitnear.z, hitnear.y);
	  		texUV = cmap.left;
	  	}
	  	//bottom
	  	if (hitnear.y >= i.b.min.y - bias && hitnear.y <= i.b.min.y + bias) {
	  		normal = vec3(0, -1, 0);
	  		texStart = vec2(i.b.min.x, i.b.min.z);
	  		texEnd = vec2(i.b.max.x, i.b.max.z);
	  		texCurrent = vec2(hitnear.x, hitnear.z);
	  		texUV = cmap.bottom;
	  	}
	  	//front
	  	if (hitnear.z >= i.b.min.z - bias && hitnear.z <= i.b.min.z + bias) {
	  		normal = vec3(0, 0, -1);
	  		texStart = vec2(i.b.min.x, i.b.min.y);
	  		texEnd = vec2(i.b.max.x, i.b.max.y);
	  		texCurrent = vec2(hitnear.x, hitnear.y);
	  		texUV = cmap.front;
	  	}
	  	//right
	  	if (hitnear.x >= i.b.max.x - bias && hitnear.x <= i.b.max.x + bias) {
	  		normal = vec3(1, 0, 0);
	  		texStart = vec2(i.b.min.z, i.b.min.y);
	  		texEnd = vec2(i.b.max.z, i.b.max.y);
	  		texCurrent = vec2(hitnear.z, hitnear.y);
	  		texUV = cmap.right;
	  	}
	  	//top
	  	if (hitnear.y >= i.b.max.y - bias && hitnear.y <= i.b.max.y + bias) {
	  		normal = vec3(0, 1, 0);
	  		texStart = vec2(i.b.min.x, i.b.min.z);
	  		texEnd = vec2(i.b.max.x, i.b.max.z);
	  		texCurrent = vec2(hitnear.x, hitnear.z);
	  		texUV = cmap.top;
	  	}
	  	//back
	  	if (hitnear.z >= i.b.max.z - bias && hitnear.z <= i.b.max.z + bias) {
	  		normal = vec3(0, 0, 1);
	  		texStart = vec2(i.b.min.x, i.b.min.y);
	  		texEnd = vec2(i.b.max.x, i.b.max.y);
	  		texCurrent = vec2(hitnear.x, hitnear.y);
	  		texUV = cmap.back;
	  	}
	  	
	  	
	  	tex = getTexture(texStart, texEnd, texCurrent, texUV, cmap.size.x, cmap.size.y, tile_texture);
    }
  	
  	float reflectance = i.b.mat.reflectance;
  	vec3 newDir = dir * normal;
 	vec4 reflectColor = vec4(0, 0, 0, 0);
 
  	hitnear -= dir * bias;
  	
  	if (reflections == 1)
  	if (reflectance > 0) {
  		newDir = reflect(dir, normal);
  		reflectColor = traceReflection(hitnear, newDir);
  	}
  	
  	vec3 sunPos = sunPosition + hitnear;
  	
  	
  	vec3 sunVector = sunPos - hitnear;
  	
  	float len = sunVector.length();
  	vec3 sunDirection = sunVector / len;
  	
  	vec4 light = vec4(1.0);
  	if (shadows == 1) {
  		light = traceLight(hitnear, sunDirection);
  	}
  	
  	
  	box b = i.b;
    return mix(vec4(light.xyz, 1.0) * b.mat.color * tex, reflectColor, reflectance);
  }
  return vec4(skyColor.xyz, 1.0);
}



layout (local_size_x = 16, local_size_y = 8) in;
void main(void) {
  
  
  
  ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(framebuffer);
  if (pix.x >= size.x || pix.y >= size.y) {
    return;
  }
  vec2 pos = vec2(pix) / vec2(size.x - 1, size.y - 1);
  vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
  
  vec4 color = trace(eye, dir);
  imageStore(framebuffer, pix, color);
}
