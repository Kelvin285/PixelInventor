#version 430 core

layout(binding = 0, rgba32f) uniform image2D framebuffer;

layout (binding = 0) uniform sampler2D tile_texture;

layout(std430, binding = 2) buffer vBuffer
{
	int voxels[];
};

layout(std430, binding = 3) readonly buffer cBuffer
{
	int chunks[];
};

layout(std430, binding = 4) readonly buffer oBuffer
{
	int octs[];
};

struct cubemap {
	vec4 top;
	vec4 bottom;
	vec4 left;
	vec4 right;
	vec4 front;
	vec4 back;
	vec4 size;
};

layout(std430, binding = 5) readonly buffer tBuffer
{
	cubemap cube_maps[];
};

uniform int width;
uniform int length;
uniform int height;

uniform int chunk_size;
uniform int oct_size;
uniform int shadows;
uniform int reflections;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;

uniform vec3 skyColor;
uniform vec3 sunColor;
uniform vec3 sunPosition;
uniform ivec3 world_position;

float bias = 0.001;

struct material {
	vec4 color;
	float reflectance;
	float transparency;
};

struct box {
  vec3 min;
  vec3 max;
  material mat;
};

#define MAX_SCENE_BOUNDS 1000.0
#define MAX_BOXES 100
material default_material = {vec4(1, 1, 1, 1), 0.0f, 0.0f};

box makeBox(vec3 position, material mat) {
	box b = {position, position + vec3(1, 1, 1), mat};
	return b;
}


int NUM_BOXES = 0;
box boxes[] = {
	makeBox(vec3(0, 0, 0), default_material)
};


struct hitinfo {
  vec2 lambda;
  int bi;
  box b;
  bool hasCubemap;
  cubemap cmap;
  vec3 normal;
  vec2 texStart;
  vec2 texEnd;
  vec2 texCurrent;
};

struct hitvoxel {
	bool hit;
	vec2 lambda;
	box b;
	int voxel;
	vec3 normal;
	vec2 texStart;
	vec2 texEnd;
	vec2 texCurrent;
};

struct intersection {
	vec2 lambda;
	vec3 normal;
	vec2 texStart;
	vec2 texEnd;
	vec2 texCurrent;
};

intersection intersectBox(vec3 origin, vec3 dir, const box b);

vec3 getNormalizedRotation(vec3 rotation) {
	float deg = 3.14 / 180.0;
	return vec3(cos(deg * rotation.y), 1, sin(deg * rotation.y));
}

vec3 rotateAroundY(vec3 a, vec3 b, float theta) {
	float x = cos(theta) * (a.x - b.x) + sin(theta) * (a.z - b.z) + b.x;
	float z = sin(theta) * (a.x - b.x) - cos(theta) * (a.z - b.z) + b.z;
	
	return vec3(x, a.y, z);
}

vec3 rotateAroundX(vec3 a, vec3 b, float theta) {
	float y = cos(theta) * (a.y - b.y) + sin(theta) * (a.z - b.z) + b.y;
	float z = sin(theta) * (a.y - b.y) - cos(theta) * (a.z - b.z) + b.z;
	
	return vec3(a.x, y, z);
}

vec3 rotateAroundZ(vec3 a, vec3 b, float theta) {
	float y = cos(theta) * (a.y - b.y) + sin(theta) * (a.x - b.x) + b.y;
	float x = sin(theta) * (a.y - b.y) - cos(theta) * (a.x - b.x) + b.x;
	
	return vec3(x, y, a.z);
}

vec3 rotateAround(vec3 a, vec3 b, vec3 theta) {
	vec3 r1 = rotateAroundX(a, b, theta.x);
	vec3 r2 = rotateAroundY(r1, b, theta.y);
	vec3 r3 = rotateAroundZ(r2, b, theta.z);
	return r3;
}

vec3 rotateDirY(vec3 dir, float theta) {
	return rotateAroundY(dir, vec3(0.0), theta);
}

vec3 rotateDirX(vec3 dir, float theta) {
	return rotateAroundX(dir, vec3(0.0), theta);
}

vec3 rotateDirZ(vec3 dir, float theta) {
	return rotateAroundZ(dir, vec3(0.0), theta);
}

vec3 rotateDir(vec3 dir, vec3 theta) {
	return rotateAround(dir, vec3(0.0), theta);
}

intersection intersectBox(vec3 origin, vec3 dir, const box b, vec3 rotation) {
  vec3 center = (b.min + b.max) / 2;
  vec3 o2 = rotateAround(origin, center, rotation);
  vec3 d2 = rotateDir(dir, rotation);
  intersection i2 = intersectBox(o2, d2, b);
  
  return i2;
}

intersection intersectBox(vec3 origin, vec3 dir, const box b) {
  vec3 tMin = (b.min - origin) / dir;
  vec3 tMax = (b.max - origin) / dir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar = min(min(t2.x, t2.y), t2.z);
  
  vec3 hitnear = origin + dir * tNear;
  vec3 hitfar = origin + dir * tFar;
  vec3 normal = vec3(0.0);
	  	//left
	  	if (hitnear.x >= b.min.x - bias && hitnear.x <= b.min.x + bias) {
	  		normal = vec3(-1, 0, 0);
	  	}
	  	//bottom
	  	if (hitnear.y >= b.min.y - bias && hitnear.y <= b.min.y + bias) {
	  		normal = vec3(0, -1, 0);
	  	}
	  	//front
	  	if (hitnear.z >= b.min.z - bias && hitnear.z <= b.min.z + bias) {
	  		normal = vec3(0, 0, -1);
	  	}
	  	//right
	  	if (hitnear.x >= b.max.x - bias && hitnear.x <= b.max.x + bias) {
	  		normal = vec3(1, 0, 0);
	  	}
	  	//top
	  	if (hitnear.y >= b.max.y - bias && hitnear.y <= b.max.y + bias) {
	  		normal = vec3(0, 1, 0);
	  	}
	  	//back
	  	if (hitnear.z >= b.max.z - bias && hitnear.z <= b.max.z + bias) {
	  		normal = vec3(0, 0, 1);
	  	}
	  	
   //top, bottom, left, right, front, back
	    vec2 texStart;
	    vec2 texEnd;
	    vec2 texCurrent;
	  	//left
	  	if (normal.x == -1) {
	  		texStart = vec2(b.min.z, b.min.y);
	  		texEnd = vec2(b.max.z, b.max.y);
	  		texCurrent = vec2(hitnear.z, hitnear.y);
	  	}
	  	//bottom
	  	if (normal.y == -1) {
	  		texStart = vec2(b.min.x, b.min.z);
	  		texEnd = vec2(b.max.x, b.max.z);
	  		texCurrent = vec2(hitnear.x, hitnear.z);
	  	}
	  	//front
	  	if (normal.z == -1) {
	  		texStart = vec2(b.min.x, b.min.y);
	  		texEnd = vec2(b.max.x, b.max.y);
	  		texCurrent = vec2(hitnear.x, hitnear.y);
	  	}
	  	//right
	  	if (normal.x == 1) {
	  		texStart = vec2(b.min.z, b.min.y);
	  		texEnd = vec2(b.max.z, b.max.y);
	  		texCurrent = vec2(hitnear.z, hitnear.y);
	  	}
	  	//top
	  	if (normal.y == 1) {
	  		texStart = vec2(b.min.x, b.min.z);
	  		texEnd = vec2(b.max.x, b.max.z);
	  		texCurrent = vec2(hitnear.x, hitnear.z);
	  	}
	  	//back
	  	if (normal.z == 1) {
	  		texStart = vec2(b.min.x, b.min.y);
	  		texEnd = vec2(b.max.x, b.max.y);
	  		texCurrent = vec2(hitnear.x, hitnear.y);
	  	}
  
  intersection i = {vec2(tNear, tFar), normal, texStart, texEnd, texCurrent};
  return i;
}

vec3 INTERSECT_POS = vec3(0, 0, 0);
const vec3 ONE = vec3(1, 1, 1);

hitvoxel intersectVoxel(vec3 origin, vec3 dir, int x, int y, int z) {
	INTERSECT_POS.x = x;
	INTERSECT_POS.y = y;
	INTERSECT_POS.z = z;
	hitvoxel h;
	h.hit = false;
	
	box b = {INTERSECT_POS, INTERSECT_POS + ONE, default_material};
	h.b = b;
	intersection I = intersectBox(origin, dir, b);
	h.lambda = I.lambda;
	h.normal = I.normal;
	h.voxel = 0;
	h.texStart = I.texStart;
	h.texEnd = I.texEnd;
	h.texCurrent = I.texCurrent;
	if (x >= 0 && y >= 0 && z >= 0 && x < width && y < height && z < length) {
		h.hit = true;
		h.voxel = voxels[x + y * width + z * width * height];
	}
	return h;
}

int getVoxel(int x, int y, int z) {
	if (x >= 0 && y >= 0 && z >= 0 && x < width && y < height && z < length) return voxels[x + y * width + z * width * height];
	return 0;
}

int getChunk(int x, int y, int z) {
    int num_chunks = width / chunk_size;
	if (x >= 0 && y >= 0 && z >= 0 && x < num_chunks && y < num_chunks && z < num_chunks) return chunks[x + y * num_chunks + z * num_chunks * num_chunks];
	return 0;
}

int getOct(int x, int y, int z) {
	int num_chunks = width / chunk_size;
  	int num_octs = width / oct_size;
  	if (x >= 0 && y >= 0 && z >= 0 && x < num_octs && y < num_octs && z < num_octs) return octs[x + y * num_octs + z * num_octs * num_octs];
	return 0;
}

const float voxelstep = bias;


bool intersectBoxes(vec3 origin, vec3 dir, out hitinfo info) {
	
	
  int maxDist = 1000;
  
  float smallest = MAX_SCENE_BOUNDS;
  bool found = false;
  bool foundChunk = false;
  
  vec3 currentPos = origin;
  vec3 vstep = dir * voxelstep;

  vec3 csize = vec3(chunk_size);
  
  
  
  if (foundChunk == false) {
  	 box chunk = {vec3(0.0), vec3(width, height, length), default_material};
	  vec2 l = intersectBox(origin, dir, chunk).lambda;
	  if (l.x > 0.0 && l.x < l.y) {
		  vec3 hit = origin + dir * l[0] - vstep;
		  currentPos = hit;
		  foundChunk = true;
	  }
  }
  int num_chunks = width / chunk_size;
  int num_octs = width / oct_size;
  
  vec3 osize = vec3(oct_size);
  
  for (int i = 0; i < maxDist; i++) {
  	int x = int(floor(currentPos.x));
  	int y = int(floor(currentPos.y));
  	int z = int(floor(currentPos.z));
  	
  	
  	if (i > 0) {
  		if (x < 0 || y < 0 || z < 0 || x > width || y > height || z > length) {
  			break;
  		}
  	}
  	
  	bool ignore = false;
  	if (x >= 0 && y >= 0 && z >= 0 && x < width  && y < height && z < length) {
  		int cx = x / chunk_size;
	  	int cy = y / chunk_size;
	  	int cz = z / chunk_size;
	  	if (getChunk(cx, cy, cz) == 0) {
	  		vec3 chunkstart = vec3(cx * chunk_size, cy * chunk_size, cz * chunk_size);
		  	vec3 chunkend = chunkstart + csize;
		  	box chunk = {chunkstart, chunkend, default_material};
		  	vec2 l = intersectBox(origin, dir, chunk).lambda;
		  	vec3 endpos = origin + dir * l[1];
		  	currentPos = endpos + vstep;
		  	ignore = true;
	  	}
	  	
	  	if (!ignore) {
	  		int ox = x / oct_size;
	  		int oy = y / oct_size;
	  		int oz = z / oct_size;
	  		if (getOct(ox, oy, oz) == 0) {
	  			vec3 chunkstart = vec3(ox * oct_size, oy * oct_size, oz * oct_size);
			  	vec3 chunkend = chunkstart + osize;
			  	box chunk = {chunkstart, chunkend, default_material};
			  	vec2 l = intersectBox(origin, dir, chunk).lambda;
			  	vec3 endpos = origin + dir * l[1];
			  	currentPos = endpos + vstep;
			  	ignore = true;
	  		}
	  	}
  	}
  	
  	if (!ignore) {
  		hitvoxel hit = intersectVoxel(origin, dir, x, y, z);
  	
	  	int voxel = hit.voxel;
	  	
		if (voxel != 0) {
			info.lambda = hit.lambda;
			info.b = hit.b;
			info.cmap = cube_maps[voxel];
			info.hasCubemap = true;
			info.normal = hit.normal;
			info.texStart = hit.texStart;
			info.texEnd = hit.texEnd;
			info.texCurrent = hit.texCurrent;
			return true;
		}
		vec3 endpos = origin + dir * hit.lambda[1];
		currentPos = endpos + vstep;
  	}
  	
  }
  
  return found;
}



vec4 traceLight(vec3 origin, vec3 dir) {
  hitinfo i;
  if (intersectBoxes(origin, dir, i)) {
  
  	vec3 hitnear = origin + dir * i.lambda[0];
  	
  	return vec4(vec3(0.5), 1);
  }
  return vec4(sunColor.xyz, 1.0);
}

vec4 getTexture(vec2 start, vec2 end, vec2 current, vec4 uv, float width, float height, sampler2D tex) {
	current -= start;
	vec2 size = end - start;
	vec2 normalized = vec2(current.x / size.x, current.y / size.y);
	
	normalized /= vec2(width, height);
	normalized.x += (1.0 / width) * mod(start.x, width);
	normalized.y += (1.0 / height) * mod(start.y, height);
	
	normalized = vec2(1.0) - normalized;
	vec2 UVpos = vec2(uv.xy);
	UVpos += (uv.zw - uv.xy) * normalized;
	
	return texture(tex, UVpos);
}

vec4 traceReflection(vec3 origin, vec3 dir) {
  hitinfo i;
  
  
  if (intersectBoxes(origin, dir, i)) {
  	//check for sunlight
  	
  	vec3 hitnear = origin + dir * i.lambda[0];
  	vec3 hitfar = origin + dir * i.lambda[1];
  	
  	
  	vec3 normal = i.normal;
  	
  	vec4 tex = vec4(1.0);

    if (i.hasCubemap) {
    	cubemap cmap = i.cmap;
    	vec2 texStart = i.texStart;
	    vec2 texEnd = i.texEnd;
	    vec2 texCurrent = i.texCurrent;
	    vec4 texUV = vec4(0, 0, 32.0, 2.0);
	  	
	  	 //top, bottom, left, right, front, back
	    
	  	//left
	  	if (i.normal.x == -1) {
	  		texUV = cmap.left;
	  	}
	  	//bottom
	  	if (i.normal.y == -1) {
	  		texUV = cmap.bottom;
	  	}
	  	//front
	  	if (i.normal.z == -1) {
	  		texUV = cmap.front;
	  	}
	  	//right
	  	if (i.normal.x == 1) {
	  		texUV = cmap.right;
	  	}
	  	//top
	  	if (i.normal.y == 1) {
	  		texUV = cmap.top;
	  	}
	  	//back
	  	if (i.normal.z == 1) {
	  		texUV = cmap.back;
	  	}
	  	
	  	tex = getTexture(texStart, texEnd, texCurrent, texUV, cmap.size.x, cmap.size.y, tile_texture);
    }
    
  	
  	hitnear -= dir * bias;
  	
  	
  	vec3 sunPos = sunPosition + hitnear;
  	
  	
  	vec3 sunVector = sunPos - hitnear;
  	
  	float len = sunVector.length();
  	vec3 sunDirection = sunVector / len;
  	
  	vec4 light = vec4(1.0);
  	if (shadows == 1) {
  		light = traceLight(hitnear, sunDirection);
  	}
  	
  	box b = i.b;
    return vec4(light.xyz, 1.0) * b.mat.color * tex;
  }
  return vec4(skyColor.xyz, 1.0);
}

vec4 trace(vec3 origin, vec3 dir) {
  hitinfo i;
  
  
  
  origin -= world_position * chunk_size;
  
  if (intersectBoxes(origin, dir, i)) {
  	//check for sunlight
  	
  	vec3 hitnear = origin + dir * i.lambda[0];
  	vec3 hitfar = origin + dir * i.lambda[1];
  	
  	
  	vec3 normal = i.normal;
  	
  	vec4 tex = vec4(1.0);

    if (i.hasCubemap) {
    	cubemap cmap = i.cmap;
    	vec2 texStart = i.texStart;
	    vec2 texEnd = i.texEnd;
	    vec2 texCurrent = i.texCurrent;
	    vec4 texUV = vec4(0, 0, 32.0, 2.0);
	  	
	  	 //top, bottom, left, right, front, back
	    
	  	//left
	  	if (i.normal.x == -1) {
	  		texUV = cmap.left;
	  	}
	  	//bottom
	  	if (i.normal.y == -1) {
	  		texUV = cmap.bottom;
	  	}
	  	//front
	  	if (i.normal.z == -1) {
	  		texUV = cmap.front;
	  	}
	  	//right
	  	if (i.normal.x == 1) {
	  		texUV = cmap.right;
	  	}
	  	//top
	  	if (i.normal.y == 1) {
	  		texUV = cmap.top;
	  	}
	  	//back
	  	if (i.normal.z == 1) {
	  		texUV = cmap.back;
	  	}
	  	
	  	tex = getTexture(texStart, texEnd, texCurrent, texUV, cmap.size.x, cmap.size.y, tile_texture);
    }
  	
  	float reflectance = i.b.mat.reflectance;
  	vec3 newDir = dir * normal;
 	vec4 reflectColor = vec4(0, 0, 0, 0);
 
  	hitnear -= dir * bias;
  	
  	if (reflections == 1)
  	if (reflectance > 0) {
  		newDir = reflect(dir, normal);
  		reflectColor = traceReflection(hitnear, newDir);
  	}
  	
  	vec3 sunPos = sunPosition + hitnear;
  	
  	
  	vec3 sunVector = sunPos - hitnear;
  	
  	float len = sunVector.length();
  	vec3 sunDirection = sunVector / len;
  	
  	vec4 light = vec4(1.0);
  	if (shadows == 1) {
  		light = traceLight(hitnear, sunDirection);
  	}
  	
  	
  	box b = i.b;
    return mix(vec4(light.xyz, 1.0) * b.mat.color * tex, reflectColor, reflectance);
  }
  return vec4(skyColor.xyz, 1.0);
}


layout (local_size_x = 16, local_size_y = 8) in;
void main(void) {
  
  
  
  ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(framebuffer);
  if (pix.x >= size.x || pix.y >= size.y) {
    return;
  }
  vec2 pos = vec2(pix) / vec2(size.x - 1, size.y - 1);
  vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
  
  float y = -7;
  float deg = 3.14 / 180.0;
  box b = {vec3(0, y, 0), vec3(1, y+1, 1), default_material};
  
  vec4 color = trace(eye, dir);
  vec3 spin = vec3(0.0);
  spin.x = 45;
  spin.z = 45;
  spin.y = 45;
  intersection i = intersectBox(eye, dir, b, spin * deg);
  vec2 l = i.lambda;
  if (l.x > 0.0 && l.x < l.y) {
   color = vec4(1.0);
  	if (i.normal.x == 1) color = vec4(1, 0, 0, 1);
  	if (i.normal.x == -1) color = vec4(0, 1, 0, 1);
  	if (i.normal.z == 1) color = vec4(1, 1, 0, 1);
  	if (i.normal.z == -1) color = vec4(0, 0, 1, 1);
  }
  
  imageStore(framebuffer, pix, color);
}
